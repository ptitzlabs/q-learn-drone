#include "drone_dynamics.hpp"

drone_dynamics::drone_dynamics() {
    b = 1.1487e-5;
    d = 2.69e-8;
    Ixx = 8.5e-3;
    Iyy = 8.5e-3;
    Izz = 15.8e-3;
    Irotor = 6.8e-5;
    m = 1.2;
    l = 0.24;
    g = 9.81;

    // pre-calc things that should remain constant

    a1_phi = (Iyy - Izz) / Ixx;
    a1_the = (Izz - Ixx) / Iyy;
    a1_psi = (Ixx - Iyy) / Izz;

    a2_phi = 0;
    a2_the = 0;

    a3_phi = l / Ixx;
    a3_the = l / Iyy;
    a3_psi = 1 / Izz;

    _xdd = new double[6];
    _xd = new double[6];
    _x = new double[6];
    _u_vec = new double[4];
    _parm_vector = new double[19];

    for (int i = 0; i < 6; i++) {
        _xdd[i] = 0;
        _xd[i] = 0;
        _x[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        _u_vec[i] = 0;
    }

    for (int i = 0; i < 6; i++) {
        _parm_vector[i] = _x[i];
        _parm_vector[i + 6] = _xd[i];
        _parm_vector[i + 12] = _xdd[i];
    }

    _parm_vector[18] =
        cos(_x[3]) *
        cos(_x[4]);  // cos(theta) x cos (phi), necessary for altitude control
}

drone_dynamics::~drone_dynamics() {
    delete[] _u_vec;
    delete[] _x;
    delete[] _xd;
    delete[] _xdd;
    delete[] _parm_vector;
}
double drone_dynamics::get_x() { return _x[0]; }
double drone_dynamics::get_y() { return _x[1]; }
double drone_dynamics::get_z() { return _x[2]; }

double drone_dynamics::get_xd() { return _xd[0]; }
double drone_dynamics::get_yd() { return _xd[1]; }
double drone_dynamics::get_zd() { return _xd[2]; }

double drone_dynamics::get_xdd() { return _xdd[1]; }
double drone_dynamics::get_ydd() { return _xdd[2]; }
double drone_dynamics::get_zdd() { return _xdd[3]; }

double drone_dynamics::get_phi() { return _x[3]; }
double drone_dynamics::get_the() { return _x[4]; }
double drone_dynamics::get_psi() { return _x[5]; }

double drone_dynamics::get_phid() { return _xd[3]; }
double drone_dynamics::get_thed() { return _xd[4]; }
double drone_dynamics::get_psid() { return _xd[5]; }

double drone_dynamics::get_phidd() { return _xdd[3]; }
double drone_dynamics::get_thedd() { return _xdd[4]; }
double drone_dynamics::get_psidd() { return _xdd[5]; }

double *drone_dynamics::get_parm_vector() { return _parm_vector; }

void drone_dynamics::state_set(double *xd_vec, double *x_vec) {
    for (int i = 0; i < 6; i++) {
        _x[i] = x_vec[i];
        _xd[i] = xd_vec[i];
    }
}

void drone_dynamics::input_set(double *u_vec) {
    // The inputs are scaled to range from -1 to 1 and produce realistic
    // behavior
    _u_vec[0] = g * m * (1 + 0.5 * u_vec[0]);
    _u_vec[1] = u_vec[1] * 0.1;
    _u_vec[2] = u_vec[2] * 0.1;
    _u_vec[3] = u_vec[3] * 0.1;

    // for (int i = 0; i < 4; i++) {
    //_u_vec[i] = u_vec[i];
    //}
}

void drone_dynamics::calc_dynamics() {
    // xdd = (cphi*sthe*cpsi+sphi*spsi)*U1m;
    // ydd = (cphi*sthe*spsi+sphi*cpsi)*U1m;
    // zdd = -g+cphi*cthe*U1m;

    // phidd = thed*psid*
}

void drone_dynamics::calc_f(double *f, double *xd_vec, double *x_vec,
                            double *u_vec) {
    double cphi = cos(x_vec[3]);
    double sphi = sin(x_vec[3]);

    double cthe = cos(x_vec[4]);
    double sthe = sin(x_vec[4]);

    double cpsi = cos(x_vec[5]);
    double spsi = sin(x_vec[5]);

    double U1m = u_vec[0] / m;

    // x_vec[0] x
    // x_vec[1] y
    // x_vec[2] z
    // x_vec[3] phi
    // x_vec[4] the
    // x_vec[5] psi

    // xyz acceleration
    f[0] = (cphi * sthe * cpsi + sphi * spsi) * U1m;  // x
    f[1] = (cphi * sthe * spsi + sphi * cpsi) * U1m;  // y
    f[2] = -g + cphi * cthe * U1m;                    // z

    // angle acceleration
    f[3] = xd_vec[4] * xd_vec[5] * a1_phi + x_vec[4] * a2_phi +
           u_vec[1] * a3_phi;  // phi
    f[4] = xd_vec[3] * xd_vec[5] * a1_the + x_vec[3] * a2_phi +
           u_vec[2] * a3_phi;                                   // theta
    f[5] = xd_vec[3] * xd_vec[4] * a1_psi + u_vec[3] * a3_psi;  // psi
}

void drone_dynamics::calc_g(double *g, double *xd_vec, double *x_vec,
                            double *u_vec) {
    g[0] = xd_vec[0];
    g[1] = xd_vec[1];
    g[2] = xd_vec[2];

    g[3] = xd_vec[3];
    g[4] = xd_vec[4];
    g[5] = xd_vec[5];
}

void drone_dynamics::euler_step(double h) {
    double *f_tmp = new double[6];
    calc_f(f_tmp, _xd, _x, _u_vec);

    for (int i = 0; i < 6; i++) {
        _xdd[i] = f_tmp[i];
        _xd[i] += h * _xdd[i];
        _x[i] += h * _xd[i];
    }
    delete[] f_tmp;
}
void drone_dynamics::rk4_step(double h) {
    double h2 = h / 2;
    double h6 = h / 6;

    double *kf1 = new double[6];
    double *kf2 = new double[6];
    double *kf3 = new double[6];
    double *kf4 = new double[6];

    double *kg1 = new double[6];
    double *kg2 = new double[6];
    double *kg3 = new double[6];
    double *kg4 = new double[6];

    double *xd_vec_tmp = new double[6];
    double *x_vec_tmp = new double[6];

    calc_f(kf1, _xd, _x, _u_vec);  // second derivatives at t0
    calc_g(kg1, _xd, _x, _u_vec);  // first derivatives at t0

    for (int i = 0; i < 6; i++) {
        xd_vec_tmp[i] = _xd[i] + h2 * kf1[i];
        x_vec_tmp[i] = _x[i] + h2 * kg1[i];
    }

    calc_f(kf2, xd_vec_tmp, x_vec_tmp, _u_vec);  // second derivatives at t+h/2
    calc_g(kg2, xd_vec_tmp, x_vec_tmp, _u_vec);  // first derivatives at t+h/2

    for (int i = 0; i < 6; i++) {
        xd_vec_tmp[i] = _xd[i] + h2 * kf2[i];
        x_vec_tmp[i] = _x[i] + h2 * kg2[i];
    }

    calc_f(kf3, xd_vec_tmp, x_vec_tmp,
           _u_vec);  // second derivatives at t+h/2, refined
    calc_g(kg3, xd_vec_tmp, x_vec_tmp,
           _u_vec);  // first derivatives at t+h/2, refined

    for (int i = 0; i < 6; i++) {
        xd_vec_tmp[i] = _xd[i] + h * kf3[i];
        x_vec_tmp[i] = _x[i] + h * kg3[i];
    }

    calc_f(kf4, xd_vec_tmp, x_vec_tmp, _u_vec);  // second derivatives at t+h
    calc_g(kg4, xd_vec_tmp, x_vec_tmp, _u_vec);  // second derivatives at t+h

    for (int i = 0; i < 6; i++) {
        _xd[i] =
            _xd[i] +
            h6 * (kf1[i] + 2 * kf2[i] + 2 * kf3[i] +
                  kf4[i]);  // updating first derivative values after timestep h
        _x[i] = _x[i] +
                h6 * (kg1[i] + 2 * kg2[i] + 2 * kg3[i] +
                      kg4[i]);  // updating state values after timestep h
    }

    calc_f(_xdd, _xd, _x, _u_vec);  // updating second derivatives
    for (int i = 0; i < 6; i++) {
        _parm_vector[i] = _x[i];         // state values
        _parm_vector[i + 6] = _xd[i];    // first derivatives
        _parm_vector[i + 12] = _xdd[i];  // second derivatives
    }

    _parm_vector[18] =
        cos(_x[3]) *
        cos(_x[4]);  // cos(theta) x cos (phi), necessary for altitude control

    // cleaning up

    delete[] kf1;
    delete[] kf2;
    delete[] kf3;
    delete[] kf4;

    delete[] kg1;
    delete[] kg2;
    delete[] kg3;
    delete[] kg4;

    delete[] xd_vec_tmp;
    delete[] x_vec_tmp;
}

void drone_dynamics::report() {
    std::cout << "Current state:\nx: " << _x[0] << " dx: " << _xd[0]
              << " phi: " << _x[3] << " dphi: " << _xd[3] << "\ny: " << _x[1]
              << " dy: " << _xd[1] << " the: " << _x[4] << " dthe: " << _xd[4]
              << "\nz: " << _x[2] << " dz: " << _xd[2] << " psi: " << _x[5]
              << " dpsi: " << _xd[5] << std::endl;
    std::cout << "Current input:"
              << "\n U1: " << _u_vec[0] << " U2: " << _u_vec[1]
              << " U3: " << _u_vec[2] << " U3: " << _u_vec[3] << std::endl;
}
